# DistributedSystems1

#### Разработка и реализация консервативного алгоритма синхронизации
#### Постановка задачи:
Разработать консервативный алгоритм синхронизации с нулевыми сообщениями для имитации взаимодействия покупателя, банка и магазина:
Предположим, что имитационная модель представляет собой совокупность трёх взаимодействующих процессов.
Покупатель в магазине делает покупку в кредит. Магазин сообщает о сделке банку, в котором открыт счёт покупателя. Покупатель приходит в банк, чтобы снять со счёта некоторую сумму. Если деньги на счёте есть, он получает эту сумму, если нет, то ему отказывают и рекомендуют пополнить счёт.

#### Реализация

Чтобы решить данную задачу были использованы:
* платформа .Net Core,
* язык C#,
* [Akka.Net](http://getakka.net/).

Akka.Net позволяет решить задачу с применением модели акторов. Можно передставить каждого участника модели отдельным актором, который обменивается с остальными с помощью сообщений. Каждый актор работает в своём отдельном потоке, в результате чего работа модели будет распределённой.

Каждый актор содержит следующие ключевые элементы:
* Логические часы Лэмпорта.
* Очереди для сообщений от других акторов. На каждого соседа по отдельной очереди.
* Расписание задач. Расписание определяется при инициализации актора. Далее новые задачи могут быть запланированы только вследствие полученных сообщений.
* Задачи. Каждый актор содержит список действий, который он может осуществлять. Каждому действию противопстовляется время выполнения. По истечении этого времени актор отсылает ответ. В терминологии акторов возможные задачи - сообщения, которые умеет обрабатывать актор.

В основе синхронизации событий лежит LBTS - нижняя граница временных меток.
Когда актор принимает сообщение от другого актора, то он скалыдвает эти сообщения в специальню очередь. Идея консервативного алгоритма заключается в том, что необходимо заблокировать выполнение текцющего актора, пока существует хотя бы одна очередь в которой нету сообщений. Для того, чтобы акторы взаимно не блокировались и работа системы не останавливалась, каждый актор после увеличением внутренних часов, а также при инициализации, рассылает всем остальным акторам нулевые сообщения. Нулевые сообщения содержат текущее время актора. Минимальная временная отметка сообщения из всех очередей и есть lbts. Актор не может выполнить запланированную задачу, пока lbts меньше чем время, на которое она запланирована. Тем самым обеспечивается хронологический порядок выполнения событий. 

В лабораторной работе было реализовано три разных актора:
 * Банк.
 * Магазин.
 * Человек.
 
 Для простоты можно представить, что человек осуществляет покупку через интернет. Также через интерент он пробует сняьб (перевести) деньги.
 
 Банк принимает следующие виды сообщений:
 * *DepositMoney* - положить деньги в банк.
 * *WithdrawMoney* - снять деньги в банке.
 * *NullMessage* - нулевое сообщение.
 
 Банк может запланировать следующие события:
 * *ApplyWithdraw* - подтвердить снятие.
 * *ApplyDeposit* - подтвердить пополнение счёта.
 
 Пользователь принимает:
 * *TransactionResponse* - результат обращения в банк.
 * *NullMessage* - нулевое сообщение.
 
 Пользователь может запланировать:
 * *MakeWithdrawRequest* - зпросить снятие денег.
 * *MakeDepositRequest* - запросить пополнение счёта.
 * *BuySomeStuff* - осуществить покупку в магазине. 
 
 Магазин принимает следующие сообщения:
 * *NullMessage*
 * *TransactionResponse* - ответ от банка.
 
 Магазин может запланировать следующие действия:
 * *GetCredit* - покупка продукта пользователем. Вызывает обращение в банк.
 
 
 Моделирование начинается с того, что пользователь актор-человек получает служебное сообщение с расписанием.
 Актор-человек отправляет сообщение в банк с целью положить деньги. Затем человек отправляет сообщение в магазин, чтобы осуществить покупку в кердит. Магазин в следствие этого должен запланировать у себя событие *GetCredit*. Тем временем человек отправляет запрос в банк, чтобы снять деньги. 
 
